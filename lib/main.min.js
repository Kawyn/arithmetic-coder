class CoderContext { static #a = 8; static #b = 255; input = []; output = []; currentMostSignificantBits = 0; bounds = { min: 0, max: 65535 }; probabilities = Array(CoderContext.#b + 3).fill(0).map((t, i) => i); cumulativeProbability = CoderContext.#b + 2; currentBitIdx = 0; currentByteIdx = 0; underflow = 0; pushBit(t) { 0 === this.currentBitIdx && this.output.push(0), this.output[this.output.length - 1] |= t << CoderContext.#a - 1 - this.currentBitIdx, this.currentBitIdx++, this.currentBitIdx === CoderContext.#a && (this.currentBitIdx = 0) } shiftBit() { let t = this.input[this.currentByteIdx]; if (void 0 === t) return 0; let i = t & 1 << CoderContext.#a - 1 - this.currentBitIdx; return this.currentBitIdx++, this.currentBitIdx === CoderContext.#a && (this.currentBitIdx = 0, this.currentByteIdx++), i > 0 ? 1 : 0 } } class ArithmeticCoder { static #c = 16; static #d = t => 65535 & t; static #e = 32768; static #f = 16384; static #g = t => t & ArithmeticCoder.#e; static #h = t => t & ArithmeticCoder.#f; static encode(t) { let i = new CoderContext; for (let e = 0; e < t.length; e++) { let r = t[e]; this.#i(i, r), this.#j(i, r), this.#k(i) } for (i.pushBit(0 !== ArithmeticCoder.#h(i.bounds.min) ? 1 : 0), i.underflow++; i.underflow > 0;)i.pushBit(0 === ArithmeticCoder.#h(i.bounds.min) ? 1 : 0), i.underflow--; return i.output } static decode(t, i) { let e = new CoderContext; e.input = t; for (let r = 0; r < 16; r++)e.currentMostSignificantBits <<= 1, e.currentMostSignificantBits += e.shiftBit(); for (let o = 0; o < i; o++) { let n = this.#l(e), s = this.#m(e, n); e.output.push(s), this.#i(e, s), this.#j(e, s), this.#n(e) } return e.output } static #i(t, i) { let e = t.bounds.max - t.bounds.min + 1, r = t.probabilities[i + 1] * e; r /= t.cumulativeProbability, t.bounds.max = ArithmeticCoder.#d(t.bounds.min + r - 1), r = t.probabilities[i] * e, r /= t.cumulativeProbability, t.bounds.min = ArithmeticCoder.#d(t.bounds.min + r) } static #j(o, n) { o.cumulativeProbability++; for (let s = n + 1; s < o.probabilities.length; s++)o.probabilities[s]++; if (o.cumulativeProbability >= 1 << ArithmeticCoder.#c - 2) { o.cumulativeProbability = 0; let u = 0; for (let d = 1; d < o.probabilities.length; d++) { let b = o.probabilities[d] - u; u = o.probabilities[d], b <= 2 ? o.probabilities[d] = ArithmeticCoder.#d(o.probabilities[d - 1] + 1) : o.probabilities[d] = ArithmeticCoder.#d(o.probabilities[d - 1] + b / 2), o.cumulativeProbability += ArithmeticCoder.#d(o.probabilities[d] - o.probabilities[d - 1]) } } } static #l(c) { let a = c.bounds.max - c.bounds.min + 1, m = c.currentMostSignificantBits - c.bounds.min + 1; return m *= c.cumulativeProbability, m--, ArithmeticCoder.#d(m / a) } static #m(l, h) { let T = 0, C = l.probabilities.length, f = Math.floor(C / 2); for (; C >= T;) { if (h < l.probabilities[f]) { f = T + Math.floor(((C = f - 1) - T) / 2); continue } if (h >= l.probabilities[f + 1]) { f = (T = f + 1) + Math.floor((C - T) / 2); continue } return f } return 0 } static #k(B) { for (; ;) { if (ArithmeticCoder.#g(B.bounds.min) === ArithmeticCoder.#g(B.bounds.max)) for (B.pushBit(0 !== ArithmeticCoder.#g(B.bounds.max) ? 1 : 0); B.underflow;)B.pushBit(0 === ArithmeticCoder.#g(B.bounds.max) ? 1 : 0), B.underflow--; else { if (!(ArithmeticCoder.#h(B.bounds.min) > 0) || 0 !== ArithmeticCoder.#h(B.bounds.max)) return; B.bounds.min &= 16383, B.bounds.max |= ArithmeticCoder.#f, B.underflow++ } B.bounds.min = ArithmeticCoder.#d(B.bounds.min << 1), B.bounds.max = ArithmeticCoder.#d(B.bounds.max << 1), B.bounds.max |= 1 } } static #n(x) { for (; ;) { if (ArithmeticCoder.#g(x.bounds.min) === ArithmeticCoder.#g(x.bounds.max)); else { if (!(ArithmeticCoder.#h(x.bounds.min) > 0) || 0 !== ArithmeticCoder.#h(x.bounds.max)) return; x.bounds.min &= 16383, x.bounds.max |= ArithmeticCoder.#f, x.currentMostSignificantBits ^= ArithmeticCoder.#f } x.bounds.min = ArithmeticCoder.#d(x.bounds.min << 1), x.bounds.max = ArithmeticCoder.#d(x.bounds.max << 1), x.bounds.max |= 1, x.currentMostSignificantBits = ArithmeticCoder.#d(x.currentMostSignificantBits << 1), x.currentMostSignificantBits |= x.shiftBit() } } }